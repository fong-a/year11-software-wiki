---
import BaseLayout from '../../../layouts/BaseLayout.astro';
import OOPNav from '../../../components/OOPNav';
import '../../../styles/global.css';

// Use Astro's base URL for proper GitHub Pages routing
const base = import.meta.env.BASE_URL;
---

<BaseLayout title="Abstraction - Object-Oriented Programming" description="Master abstraction in OOP with practical banking and gaming examples showing how to hide complexity">
  <!-- Breadcrumb Bar -->
  <div class="bg-gray-50 border-b border-gray-200 py-3">
    <div class="container mx-auto px-6">
      <nav>
        <a href={`${base}/`} class="text-sm text-gray-600 hover:text-gray-900 transition-colors">Home</a>
        <span class="text-sm text-gray-400 mx-2">></span>
        <a href={`${base}/topics/object-oriented-programming`} class="text-sm text-gray-600 hover:text-gray-900 transition-colors">Object-Oriented Programming</a>
        <span class="text-sm text-gray-400 mx-2">></span>
        <span class="text-sm text-gray-900 font-medium">Abstraction</span>
      </nav>
    </div>
  </div>

  <div class="min-h-screen bg-gray-50 py-8">
    <div class="container mx-auto px-6">
      <div class="grid lg:grid-cols-4 gap-8">
        <!-- Navigation Sidebar -->
        <div class="lg:col-span-1">
          <div class="sticky top-8 bg-white rounded-lg shadow-sm p-6">
            <OOPNav 
              client:load 
              currentPage="/topics/object-oriented-programming/abstraction"
            />
          </div>
        </div>

        <!-- Main Content -->
        <div class="lg:col-span-3">
          <div class="bg-white rounded-lg shadow-sm p-8">
            <h1 class="text-4xl font-bold mb-6">Abstraction</h1>
            
            <div class="mb-8 p-6 bg-gradient-to-r from-orange-50 to-yellow-50 rounded-xl border border-orange-200">
              <p class="text-orange-900 text-lg leading-relaxed">
                <strong>Abstraction</strong> hides the complex inner workings while providing a simple, clean interface. Like using your phone's camera - you just tap to take a photo, without needing to understand the complex image processing happening inside!
              </p>
            </div>

            <!-- What is Abstraction? -->
            <div class="mb-8">
              <h2 class="text-2xl font-semibold mb-6 text-gray-900">What is Abstraction?</h2>
              
              <div class="bg-orange-50 p-6 rounded-lg border border-orange-200 mb-6">
                <p class="text-orange-800 mb-4">
                  <strong>Abstraction</strong> is the process of hiding implementation details while exposing only the essential features of an object. It creates a simplified interface that users can interact with without understanding the complexity underneath.
                </p>
                
                <div class="bg-white p-4 rounded border border-orange-300">
                  <h3 class="font-medium text-orange-800 mb-2">Real-World Examples:</h3>
                  <ul class="text-sm text-orange-700 space-y-1">
                    <li>• <strong>ATM Machine:</strong> Press buttons → Get money (don't need to know banking protocols)</li>
                    <li>• <strong>Car:</strong> Turn key → Engine starts (don't need to know fuel injection details)</li>
                    <li>• <strong>TV Remote:</strong> Press power → TV turns on (don't need to know electronics)</li>
                    <li>• <strong>Website:</strong> Click login → Access account (don't need to know authentication code)</li>
                  </ul>
                </div>
              </div>
            </div>

            <!-- Gaming Example: Game Engine Abstraction -->
            <div class="mb-8">
              <h2 class="text-2xl font-semibold mb-6 text-red-800">🎮 Gaming Example: Game Engine Abstraction</h2>
              
              <div class="mb-6">
                <h3 class="text-xl font-semibold mb-4 text-gray-900">Complex Game Engine (Hidden Implementation)</h3>
                <div class="bg-gray-100 rounded-lg p-4 border-l-4 border-blue-400 mb-4">
                  <pre class="text-gray-800 text-sm"><code>class ComplexGameEngine:
    """This complex implementation is HIDDEN from game developers"""
    
    def __init__(self):
        self._graphics_buffer = []
        self._physics_objects = []
        self._audio_channels = []
    
    def _update_physics_simulation(self, dt):
        """Complex physics calculations"""
        for obj in self._physics_objects:
            # Apply gravity, collision detection, momentum, etc.
            obj.velocity += obj.acceleration * dt
            obj.position += obj.velocity * dt
    
    def _render_frame(self):
        """Complex rendering pipeline"""
        # Clear buffers, apply shaders, render objects, etc.
        pass
    
    def _process_audio(self):
        """Complex audio mixing"""
        # Mix audio channels, apply effects, etc.
        pass</code></pre>
                </div>
              </div>

              <div class="mb-6">
                <h3 class="text-xl font-semibold mb-4 text-gray-900">Simple Game Interface (Abstraction Layer)</h3>
                <div class="bg-gray-100 rounded-lg p-4 border-l-4 border-blue-400 mb-4">
                  <pre class="text-gray-800 text-sm"><code>class GameEngine:
    """Simple, clean interface that HIDES the complexity"""
    
    def __init__(self):
        self._complex_engine = ComplexGameEngine()
    
    def create_character(self, name, x, y):
        """Simple interface - complexity is hidden"""
        character = Character(name, x, y)
        return character
    
    def move_character(self, character, direction):
        """Simple interface - just specify direction"""
        # Complex implementation hidden inside
        pass  # Movement logic happens here
    
    def play_sound(self, sound_name):
        """Simple interface - just name the sound"""
        # Complex audio processing hidden
        pass  # Audio processing happens here
    
    def update_game(self):
        """One simple call handles everything"""
        # All complexity hidden behind this simple method
        self._complex_engine._update_physics_simulation(0.016)
        self._complex_engine._process_audio()
        self._complex_engine._render_frame()

# ABSTRACTION IN ACTION: Game developers use simple interface
class SimpleGame:
    def __init__(self):
        self.engine = GameEngine()  # Simple interface
        
    def create_player(self):
        # Don't need to know physics, graphics, audio details
        player = self.engine.create_character("Player", 100, 100)
        return player
    
    def game_loop(self):
        # One simple call handles all complex systems
        self.engine.update_game()  # Physics, audio, graphics!</code></pre>
                </div>
                
                <div class="bg-red-50 p-4 rounded border border-red-200">
                  <h4 class="font-medium text-red-800 mb-2">🎯 Abstraction Benefits Here:</h4>
                  <ul class="text-sm text-red-700 space-y-1">
                    <li>• Game developers don't need to understand physics engines</li>
                    <li>• Complex rendering is hidden behind simple method calls</li>
                    <li>• Audio processing complexity is abstracted away</li>
                    <li>• Easy to use interface enables rapid game development</li>
                  </ul>
                </div>
              </div>
            </div>

            <!-- Banking Example: ATM System Abstraction -->
            <div class="mb-8">
              <h2 class="text-2xl font-semibold mb-6 text-blue-800">💼 Banking Example: ATM System Abstraction</h2>
              
              <div class="mb-6">
                <h3 class="text-xl font-semibold mb-4 text-gray-900">Complex Banking Backend (Hidden Implementation)</h3>
                <div class="bg-gray-100 rounded-lg p-4 border-l-4 border-blue-400 mb-4">
                  <pre class="text-gray-800 text-sm"><code>class ComplexBankingSystem:
    """This complex implementation is HIDDEN from ATM users"""
    
    def __init__(self):
        self._database_connections = &#123;&#125;
        self._security_protocols = &#123;&#125;
        self._encryption_keys = &#123;&#125;
    
    def _authenticate_user(self, card_number, pin):
        """Complex authentication process"""
        # Check card validity, encrypt PIN, verify against database
        encrypted_pin = self._encrypt_pin(pin)
        account_data = self._query_secure_database(card_number)
        return self._verify_credentials(account_data, encrypted_pin)
    
    def _process_withdrawal(self, account, amount):
        """Complex transaction processing"""
        # Check balances, update multiple systems
        available = self._get_available_balance(account)
        if amount &lt;= available:
            self._update_core_banking_system(account, -amount)
            return True
        return False
    
    def _dispense_cash(self, amount):
        """Complex cash dispensing mechanism"""
        # Calculate bills needed, dispense cash
        bills_needed = self._calculate_bill_combination(amount)
        self._dispense_bills(bills_needed)
        return True</code></pre>
                </div>
              </div>

              <div class="mb-6">
                <h3 class="text-xl font-semibold mb-4 text-gray-900">Simple ATM Interface (Abstraction Layer)</h3>
                <div class="bg-gray-100 rounded-lg p-4 border-l-4 border-blue-400 mb-4">
                  <pre class="text-gray-800 text-sm"><code>class ATM:
    """Simple, clean interface that HIDES the complexity"""
    
    def __init__(self):
        self._banking_system = ComplexBankingSystem()
        self._current_user = None
    
    def insert_card_and_login(self, card_number, pin):
        """Simple login - complexity is hidden"""
        print("Verifying credentials...")
        
        # Complex authentication happens behind the scenes
        if self._banking_system._authenticate_user(card_number, pin):
            self._current_user = card_number
            return True
        else:
            print("Invalid credentials.")
            return False
    
    def check_balance(self):
        """Simple balance check - complexity hidden"""
        if not self._current_user:
            print("Please login first.")
            return
        
        # Complex database queries happen automatically
        balance = self._banking_system._get_account_balance(self._current_user)
        print("Your balance is: $" + str(balance))
    
    def withdraw_cash(self, amount):
        """Simple withdrawal - all complexity hidden"""
        if not self._current_user:
            print("Please login first.")
            return False
        
        # Complex transaction processing hidden
        success = self._banking_system._process_withdrawal(self._current_user, amount)
        
        if success:
            self._banking_system._dispense_cash(amount)
            print("Please take your $" + str(amount) + " cash.")
            return True
        else:
            print("Transaction declined.")
            return False

# ABSTRACTION IN ACTION: Customers use simple interface
class CustomerExperience:
    def use_atm(self):
        atm = ATM()
        
        # Customer doesn't need to know about:
        # - Database queries, encryption, security systems
        # - Cash management, bill counting algorithms
        
        # They just use simple, intuitive methods:
        if atm.insert_card_and_login("1234-5678", "9876"):
            atm.check_balance()
            atm.withdraw_cash(100)</code></pre>
                </div>
                
                <div class="bg-blue-50 p-4 rounded border border-blue-200">
                  <h4 class="font-medium text-blue-800 mb-2">🏦 Abstraction Benefits Here:</h4>
                  <ul class="text-sm text-blue-700 space-y-1">
                    <li>• Customers don't need to understand banking protocols</li>
                    <li>• Security complexity is completely hidden</li>
                    <li>• Database operations are abstracted away</li>
                    <li>• Simple interface makes banking accessible to everyone</li>
                  </ul>
                </div>
              </div>
            </div>

            <!-- Abstract Base Classes in Python -->
            <div class="mb-8">
              <h2 class="text-2xl font-semibold mb-6 text-gray-900">Python Abstract Base Classes (ABC)</h2>
              
              <div class="bg-purple-50 p-6 rounded-lg border border-purple-200 mb-6">
                <p class="text-purple-800 mb-4">
                  Python provides the <code>abc</code> module to create abstract base classes that define interfaces without implementation.
                </p>
              </div>

              <div class="bg-gray-100 rounded-lg p-4 border-l-4 border-blue-400 mb-4">
                <pre class="text-gray-800 text-sm"><code>from abc import ABC, abstractmethod

class Vehicle(ABC):  # Abstract base class
    """Defines the interface but not the implementation"""
    
    def __init__(self, make, model):
        self.make = make
        self.model = model
    
    @abstractmethod
    def start_engine(self):
        """Must be implemented by subclasses"""
        pass
    
    @abstractmethod
    def get_fuel_type(self):
        """Must be implemented by subclasses"""
        pass
    
    # Concrete method (same for all vehicles)
    def get_info(self):
        return f"&#123;self.make&#125; &#123;self.model&#125;"

class Car(Vehicle):  # Concrete implementation
    def __init__(self, make, model):
        super().__init__(make, model)
        self.engine_running = False
    
    def start_engine(self):  # Implementation hidden from user
        if not self.engine_running:
            self.engine_running = True
            return "Car engine started"
        return "Engine already running"
    
    def get_fuel_type(self):
        return "Gasoline"

class ElectricCar(Vehicle):  # Different implementation, same interface
    def __init__(self, make, model):
        super().__init__(make, model)
        self.power_on = False
    
    def start_engine(self):  # Different implementation, same interface
        if not self.power_on:
            self.power_on = True
            return "Electric motor activated"
        return "Motor already active"
    
    def get_fuel_type(self):
        return "Electricity"

# ABSTRACTION IN ACTION: Same interface, different implementations
vehicles = [
    Car("Toyota", "Camry"),
    ElectricCar("Tesla", "Model 3")
]

print("=== ABSTRACTION DEMO ===")
for vehicle in vehicles:
    print("\n" + vehicle.get_info() + " (" + vehicle.get_fuel_type() + ")")
    print(vehicle.start_engine())  # Same method call, different behavior

# User doesn't need to know how engines work internally!</code></pre>
              </div>
            </div>

            <!-- Types of Abstraction -->
            <div class="mb-8">
              <h2 class="text-2xl font-semibold mb-6 text-gray-900">Types of Abstraction</h2>
              
              <div class="grid md:grid-cols-2 gap-6">
                <div class="bg-green-50 p-6 rounded-lg border border-green-200">
                  <h3 class="text-lg font-semibold text-green-800 mb-4">Data Abstraction</h3>
                  <p class="text-green-700 text-sm mb-3">
                    Hiding the internal representation of data and providing methods to interact with it.
                  </p>
                  <div class="bg-white p-3 rounded border border-green-300">
                    <code class="text-sm">balance = account.get_balance()  # Don't know how it's stored</code>
                  </div>
                </div>
                
                <div class="bg-blue-50 p-6 rounded-lg border border-blue-200">
                  <h3 class="text-lg font-semibold text-blue-800 mb-4">Process Abstraction</h3>
                  <p class="text-blue-700 text-sm mb-3">
                    Hiding the complex implementation details of operations and algorithms.
                  </p>
                  <div class="bg-white p-3 rounded border border-blue-300">
                    <code class="text-sm">sorted_list = sort(my_list)  # Don't know the sorting algorithm</code>
                  </div>
                </div>
                
                <div class="bg-purple-50 p-6 rounded-lg border border-purple-200">
                  <h3 class="text-lg font-semibold text-purple-800 mb-4">Interface Abstraction</h3>
                  <p class="text-purple-700 text-sm mb-3">
                    Providing a common interface that different implementations can follow.
                  </p>
                  <div class="bg-white p-3 rounded border border-purple-300">
                    <code class="text-sm">vehicle.start()  # Works for cars, trucks, motorcycles</code>
                  </div>
                </div>
                
                <div class="bg-orange-50 p-6 rounded-lg border border-orange-200">
                  <h3 class="text-lg font-semibold text-orange-800 mb-4">Control Abstraction</h3>
                  <p class="text-orange-700 text-sm mb-3">
                    Hiding complex control flow and decision-making logic behind simple method calls.
                  </p>
                  <div class="bg-white p-3 rounded border border-orange-300">
                    <code class="text-sm">ai.make_move()  # Hides complex decision algorithms</code>
                  </div>
                </div>
              </div>
            </div>

            <!-- Benefits of Abstraction -->
            <div class="mb-8">
              <h2 class="text-2xl font-semibold mb-6 text-gray-900">Why Use Abstraction?</h2>
              
              <div class="grid md:grid-cols-3 gap-6">
                <div class="bg-green-100 p-4 rounded-lg">
                  <h3 class="font-semibold text-green-800 mb-2">Simplicity</h3>
                  <p class="text-green-700 text-sm">Users interact with simple interfaces instead of complex implementations.</p>
                </div>
                
                <div class="bg-blue-100 p-4 rounded-lg">
                  <h3 class="font-semibold text-blue-800 mb-2">Maintainability</h3>
                  <p class="text-blue-700 text-sm">Internal changes don't affect code that uses the abstracted interface.</p>
                </div>
                
                <div class="bg-purple-100 p-4 rounded-lg">
                  <h3 class="font-semibold text-purple-800 mb-2">Reusability</h3>
                  <p class="text-purple-700 text-sm">Abstract interfaces can be implemented by multiple concrete classes.</p>
                </div>
                
                <div class="bg-orange-100 p-4 rounded-lg">
                  <h3 class="font-semibold text-orange-800 mb-2">Security</h3>
                  <p class="text-orange-700 text-sm">Sensitive implementation details are hidden from users.</p>
                </div>
                
                <div class="bg-red-100 p-4 rounded-lg">
                  <h3 class="font-semibold text-red-800 mb-2">Flexibility</h3>
                  <p class="text-red-700 text-sm">Different implementations can be swapped without changing user code.</p>
                </div>
                
                <div class="bg-indigo-100 p-4 rounded-lg">
                  <h3 class="font-semibold text-indigo-800 mb-2">Focus</h3>
                  <p class="text-indigo-700 text-sm">Developers focus on what objects do, not how they do it.</p>
                </div>
              </div>
            </div>

            <!-- NESA Exam Context -->
            <div class="bg-amber-50 p-4 rounded-lg border border-amber-200">
              <div class="flex items-start">
                <svg class="w-5 h-5 text-amber-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <div>
                  <p class="font-semibold text-amber-900 mb-1">NESA Exam Focus</p>
                  <p class="text-amber-800 text-sm">Understand how abstraction hides implementation complexity while providing simple interfaces. Be able to identify abstract base classes and concrete implementations. Know the benefits of abstraction for code maintainability, security, and user experience. Practice explaining real-world examples of abstraction like ATMs, car controls, or smartphone interfaces.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>